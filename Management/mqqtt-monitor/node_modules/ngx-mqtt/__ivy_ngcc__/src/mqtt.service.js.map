{"version":3,"file":"mqtt.service.js","sources":["mqtt.service.js"],"names":[],"mappings":";AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;8CA6Y8C,AAIvC;;;;;;;;;;;;;;;;;kCAGa","sourcesContent":["var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nimport { EventEmitter, Inject, Injectable } from '@angular/core';\nimport { connect } from '../vendor/mqtt.min.js';\nimport * as extend from 'xtend';\nimport { BehaviorSubject, merge, Observable, Subscription, Subject, using } from 'rxjs';\nimport { filter, publish, publishReplay, refCount } from 'rxjs/operators';\nimport { MqttConnectionState } from './mqtt.model';\nimport { MqttServiceConfig, MqttClientService } from './mqtt.module';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"./mqtt.module\";\n/**\n * With an instance of MqttService, you can observe and subscribe to MQTT in multiple places, e.g. in different components,\n * to only subscribe to the broker once per MQTT filter.\n * It also handles proper unsubscription from the broker, if the last observable with a filter is closed.\n */\nvar MqttService = /** @class */ (function () {\n    /**\n     * The constructor needs [connection options]{@link IMqttServiceOptions} regarding the broker and some\n     * options to configure behavior of this service, like if the connection to the broker\n     * should be established on creation of this service or not.\n     */\n    function MqttService(options, client) {\n        var _this = this;\n        this.options = options;\n        this.client = client;\n        /** a map of all mqtt observables by filter */\n        this.observables = {};\n        /** the connection state */\n        this.state = new BehaviorSubject(MqttConnectionState.CLOSED);\n        /** an observable of the last mqtt message */\n        this.messages = new Subject();\n        this._clientId = this._generateClientId();\n        this._connectTimeout = 10000;\n        this._reconnectPeriod = 10000;\n        this._url = undefined;\n        this._onConnect = new EventEmitter();\n        this._onReconnect = new EventEmitter();\n        this._onClose = new EventEmitter();\n        this._onOffline = new EventEmitter();\n        this._onError = new EventEmitter();\n        this._onEnd = new EventEmitter();\n        this._onMessage = new EventEmitter();\n        this._onSuback = new EventEmitter();\n        this._onPacketsend = new EventEmitter();\n        this._onPacketreceive = new EventEmitter();\n        this._handleOnConnect = function (e) {\n            if (_this.options.connectOnCreate === true) {\n                Object.keys(_this.observables).forEach(function (filter) {\n                    _this.client.subscribe(filter);\n                });\n            }\n            _this.state.next(MqttConnectionState.CONNECTED);\n            _this._onConnect.emit(e);\n        };\n        this._handleOnReconnect = function () {\n            if (_this.options.connectOnCreate === true) {\n                Object.keys(_this.observables).forEach(function (filter) {\n                    _this.client.subscribe(filter);\n                });\n            }\n            _this.state.next(MqttConnectionState.CONNECTING);\n            _this._onReconnect.emit();\n        };\n        this._handleOnClose = function () {\n            _this.state.next(MqttConnectionState.CLOSED);\n            _this._onClose.emit();\n        };\n        this._handleOnOffline = function () {\n            _this._onOffline.emit();\n        };\n        this._handleOnError = function (e) {\n            _this._onError.emit(e);\n            console.error(e);\n        };\n        this._handleOnEnd = function () {\n            _this._onEnd.emit();\n        };\n        this._handleOnMessage = function (topic, msg, packet) {\n            _this._onMessage.emit(packet);\n            if (packet.cmd === 'publish') {\n                _this.messages.next(packet);\n            }\n        };\n        this._handleOnPacketsend = function (e) {\n            _this._onPacketsend.emit();\n        };\n        this._handleOnPacketreceive = function (e) {\n            _this._onPacketreceive.emit();\n        };\n        if (options.connectOnCreate !== false) {\n            this.connect({}, client);\n        }\n        this.state.subscribe();\n    }\n    MqttService_1 = MqttService;\n    /**\n     * connect manually connects to the mqtt broker.\n     */\n    MqttService.prototype.connect = function (opts, client) {\n        var options = extend(this.options || {}, opts);\n        var protocol = options.protocol || 'ws';\n        var hostname = options.hostname || 'localhost';\n        if (options.url) {\n            this._url = options.url;\n        }\n        else {\n            this._url = protocol + \"://\" + hostname;\n            this._url += options.port ? \":\" + options.port : '';\n            this._url += options.path ? \"\" + options.path : '';\n        }\n        this.state.next(MqttConnectionState.CONNECTING);\n        var mergedOptions = extend({\n            clientId: this._clientId,\n            reconnectPeriod: this._reconnectPeriod,\n            connectTimeout: this._connectTimeout\n        }, options);\n        if (this.client) {\n            this.client.end(true);\n        }\n        if (!client) {\n            this.client = connect(this._url, mergedOptions);\n        }\n        else {\n            this.client = client;\n        }\n        this._clientId = mergedOptions.clientId;\n        this.client.on('connect', this._handleOnConnect);\n        this.client.on('reconnect', this._handleOnReconnect);\n        this.client.on('close', this._handleOnClose);\n        this.client.on('offline', this._handleOnOffline);\n        this.client.on('error', this._handleOnError);\n        this.client.stream.on('error', this._handleOnError);\n        this.client.on('end', this._handleOnEnd);\n        this.client.on('message', this._handleOnMessage);\n        this.client.on('packetsend', this._handleOnPacketsend);\n        this.client.on('packetreceive', this._handleOnPacketreceive);\n    };\n    Object.defineProperty(MqttService.prototype, \"clientId\", {\n        /**\n         * gets the _clientId\n         */\n        get: function () {\n            return this._clientId;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * disconnect disconnects from the mqtt client.\n     * This method `should` be executed when leaving the application.\n     */\n    MqttService.prototype.disconnect = function (force) {\n        if (force === void 0) { force = true; }\n        if (!this.client) {\n            throw new Error('mqtt client not connected');\n        }\n        this.client.end(force);\n    };\n    /**\n     * With this method, you can observe messages for a mqtt topic.\n     * The observable will only emit messages matching the filter.\n     * The first one subscribing to the resulting observable executes a mqtt subscribe.\n     * The last one unsubscribing this filter executes a mqtt unsubscribe.\n     * Every new subscriber gets the latest message.\n     */\n    MqttService.prototype.observeRetained = function (filterString, opts) {\n        if (opts === void 0) { opts = { qos: 1 }; }\n        return this._generalObserve(filterString, function () { return publishReplay(1); }, opts);\n    };\n    /**\n     * With this method, you can observe messages for a mqtt topic.\n     * The observable will only emit messages matching the filter.\n     * The first one subscribing to the resulting observable executes a mqtt subscribe.\n     * The last one unsubscribing this filter executes a mqtt unsubscribe.\n     */\n    MqttService.prototype.observe = function (filterString, opts) {\n        if (opts === void 0) { opts = { qos: 1 }; }\n        return this._generalObserve(filterString, function () { return publish(); }, opts);\n    };\n    /**\n     * With this method, you can observe messages for a mqtt topic.\n     * The observable will only emit messages matching the filter.\n     * The first one subscribing to the resulting observable executes a mqtt subscribe.\n     * The last one unsubscribing this filter executes a mqtt unsubscribe.\n     * Depending on the publish function, the messages will either be replayed after new\n     * subscribers subscribe or the messages are just passed through\n     */\n    MqttService.prototype._generalObserve = function (filterString, publishFn, opts) {\n        var _this = this;\n        if (!this.client) {\n            throw new Error('mqtt client not connected');\n        }\n        if (!this.observables[filterString]) {\n            var rejected_1 = new Subject();\n            this.observables[filterString] = using(\n            // resourceFactory: Do the actual ref-counting MQTT subscription.\n            // refcount is decreased on unsubscribe.\n            function () {\n                var subscription = new Subscription();\n                _this.client.subscribe(filterString, opts, function (err, granted) {\n                    if (granted) { // granted can be undefined when an error occurs when the client is disconnecting\n                        granted.forEach(function (granted_) {\n                            if (granted_.qos === 128) {\n                                delete _this.observables[granted_.topic];\n                                _this.client.unsubscribe(granted_.topic);\n                                rejected_1.error(\"subscription for '\" + granted_.topic + \"' rejected!\");\n                            }\n                            _this._onSuback.emit({ filter: filterString, granted: granted_.qos !== 128 });\n                        });\n                    }\n                });\n                subscription.add(function () {\n                    delete _this.observables[filterString];\n                    _this.client.unsubscribe(filterString);\n                });\n                return subscription;\n            }, \n            // observableFactory: Create the observable that is consumed from.\n            // This part is not executed until the Observable returned by\n            // `observe` gets actually subscribed.\n            function (subscription) { return merge(rejected_1, _this.messages); })\n                .pipe(filter(function (msg) { return MqttService_1.filterMatchesTopic(filterString, msg.topic); }), publishFn(), refCount());\n        }\n        return this.observables[filterString];\n    };\n    /**\n     * This method returns an observable for a topic with optional options.\n     * After subscribing, the actual mqtt publication will be executed and\n     * the observable will emit an empty value and completes, if publishing was successful\n     * or throws an error, if the publication fails.\n     */\n    MqttService.prototype.publish = function (topic, message, options) {\n        var _this = this;\n        if (!this.client) {\n            throw new Error('mqtt client not connected');\n        }\n        var source = Observable.create(function (obs) {\n            _this.client.publish(topic, message, options, function (err) {\n                if (err) {\n                    obs.error(err);\n                }\n                else {\n                    obs.next(null);\n                    obs.complete();\n                }\n            });\n        });\n        return source;\n    };\n    /**\n     * This method publishes a message for a topic with optional options.\n     * If an error occurs, it will throw.\n     */\n    MqttService.prototype.unsafePublish = function (topic, message, options) {\n        if (!this.client) {\n            throw new Error('mqtt client not connected');\n        }\n        this.client.publish(topic, message, options, function (err) {\n            if (err) {\n                throw (err);\n            }\n        });\n    };\n    /**\n     * This static method shall be used to determine whether a MQTT\n     * topic matches a given filter. The matching rules are specified in the MQTT\n     * standard documentation and in the library test suite.\n     *\n     * @param  {string}  filter A filter may contain wildcards like '#' and '+'.\n     * @param  {string}  topic  A topic may not contain wildcards.\n     * @return {boolean}        true on match and false otherwise.\n     */\n    MqttService.filterMatchesTopic = function (filter, topic) {\n        if (filter[0] === '#' && topic[0] === '$') {\n            return false;\n        }\n        // Preparation: split and reverse on '/'. The JavaScript split function is sane.\n        var fs = (filter || '').split('/').reverse();\n        var ts = (topic || '').split('/').reverse();\n        // This function is tail recursive and compares both arrays one element at a time.\n        var match = function () {\n            // Cutting of the last element of both the filter and the topic using pop().\n            var f = fs.pop();\n            var t = ts.pop();\n            switch (f) {\n                // In case the filter level is '#', this is a match no matter whether\n                // the topic is undefined on this level or not ('#' matches parent element as well!).\n                case '#':\n                    return true;\n                // In case the filter level is '+', we shall dive into the recursion only if t is not undefined.\n                case '+':\n                    return t ? match() : false;\n                // In all other cases the filter level must match the topic level,\n                // both must be defined and the filter tail must match the topic\n                // tail (which is determined by the recursive call of match()).\n                default:\n                    return f === t && (f === undefined ? true : match());\n            }\n        };\n        return match();\n    };\n    Object.defineProperty(MqttService.prototype, \"onConnect\", {\n        /** An EventEmitter to listen to connect messages */\n        get: function () {\n            return this._onConnect;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MqttService.prototype, \"onReconnect\", {\n        /** An EventEmitter to listen to reconnect messages */\n        get: function () {\n            return this._onReconnect;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MqttService.prototype, \"onClose\", {\n        /** An EventEmitter to listen to close messages */\n        get: function () {\n            return this._onClose;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MqttService.prototype, \"onOffline\", {\n        /** An EventEmitter to listen to offline events */\n        get: function () {\n            return this._onOffline;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MqttService.prototype, \"onError\", {\n        /** An EventEmitter to listen to error events */\n        get: function () {\n            return this._onError;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MqttService.prototype, \"onEnd\", {\n        /** An EventEmitter to listen to close messages */\n        get: function () {\n            return this._onEnd;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MqttService.prototype, \"onMessage\", {\n        /** An EventEmitter to listen to message events */\n        get: function () {\n            return this._onMessage;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MqttService.prototype, \"onPacketsend\", {\n        /** An EventEmitter to listen to packetsend messages */\n        get: function () {\n            return this._onPacketsend;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MqttService.prototype, \"onPacketreceive\", {\n        /** An EventEmitter to listen to packetreceive messages */\n        get: function () {\n            return this._onPacketreceive;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MqttService.prototype, \"onSuback\", {\n        /** An EventEmitter to listen to suback events */\n        get: function () {\n            return this._onSuback;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    MqttService.prototype._generateClientId = function () {\n        return 'client-' + Math.random().toString(36).substr(2, 19);\n    };\n    var MqttService_1;\n    MqttService.ngInjectableDef = i0.defineInjectable({ factory: function MqttService_Factory() { return new MqttService(i0.inject(i1.MqttServiceConfig), i0.inject(i1.MqttClientService)); }, token: MqttService, providedIn: \"root\" });\n    MqttService = MqttService_1 = __decorate([\n        Injectable({\n            providedIn: 'root',\n        }),\n        __param(0, Inject(MqttServiceConfig)),\n        __param(1, Inject(MqttClientService)),\n        __metadata(\"design:paramtypes\", [Object, Object])\n    ], MqttService);\n    return MqttService;\n}());\nexport { MqttService };\n"]}